* * * * * * * * * * * * * * * * * * * * * * * * * * * PRINCIPLES * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Понятия
* * * Хрупкий код - в одном месте изменил, в другом сломалось.
* * * Жесткий код - когда в одном классе очень часто используется другой класс, например статические методы и т. д.
* * *               Таким образом, этот класс уже будет зависить от другого класса и его нельзя будет выбросить.
* * *               Эту проблему например можно решить созданием интерфейса, и часто используемый класс наследовать от
* * *               этого интерфейса, и уже часто использовать не сам класс, а интерфейс.
* * * Ортогональный код - независимый код от чего-то конкретного.
*
* Все аргументы всех методов должны быть финальными. (Не относится к SOLID)
* * * Это объясняется тем, что без модификатора final возможно изменение аргументов метода внутри метода. Это считается
* * * плохой практикой. Так как мы передали одно значение, а после его в середине метода меняем. Так делать нельзя.
* * * Программист, какой видит впервые ваш код, может не заметить что значение переменной меняется и вы сами можете
* * * забыть и не заметить. Поэтому такая проблема решается созданием новой переменной, какой нужно для начала присвоить
* * * значение аргумента метода, а после уже применять для изменения значения.
* * * Например:
* * * * * public void operation(int arg1, int arg2) {
* * * * *     int sum = arg1 + arg2;
* * * * *     int incArg; // Создаём переменную, какой присвоем новое значение arg
* * * * *
* * * * *     if (sum > arg1) {
* * * * *         // arg1++; // Мы увеличиваем значение переменной, то есть изменяем его. Так делать нельзя!
* * * * *         incArg = arg1; // Присваиваем новой переменной значение аргумента, какой хотим изменить
* * * * *         incArg++; // Изменяем его значение
* * * * *     } else {
* * * * *         // arg2++; // Тоже самое. Так делать нельзя!
* * * * *         incArg = arg2;
* * * * *         incArg++;
* * * * *     }
* * * * * }
*
* ПРЕДОСТЕРЕЖЕНИЕ
* * * Принципи желательно использовать только в том коде, какой возможно может изменится. Так как излишнее
* * * использование принципов может только усложнить код.
*
* PRINCIPLES OF OBJECT ORIENTED DESIGN
* * * * * * * * * * * * * * * * * * *
*
* Принцип единственной обязанности (Single responsibility principle)
* * * - Класс должен иметь только одну ответственность (то есть повлиять на спецификацию класса должно быть
* * *   способно только одно потенциальное изменение в спецификации ПО) ©Википедия
* * * - Класс должен иметь только одну причину для изменений. ©Head First
* * *
* * * Например есть бин User. Это самый обычный бин, в нём поля и геттеры, сеттеры. И вдруг приходит мысль, а почему бы
* * * этому классу сразу не иметь метод для записи себя в базу данных. Он сразу имеет доступ ко всем полям и это удобно.
* * * Но так делать нельзя!
* * *
* * * Таким образом у класса появляются сразу две обязанности. Иметь данные клиента и записывать данные клиента в базу.
* * * Если нужно будет изменить поле класса, мы будем заходить в User и менять, если нужно будет изменить запись в базу,
* * * мы будем заходить опять же в класс User и менять. Это не правильно.
* * *
* * * На замену такого подхода. Можно например создать класс UserDAO, у какого будет одна обязанность. Это следить за
* * * записью данных клиента в базу.
* * *
* * * С помощью этого принципа, мы можем быть уверены, что если мы изменили один класс, другие классы будут в рабочем
* * * состоянии.
*
* Принцип открытости/закрытости (Open/closed principle)
* * * - «программные сущности ... должны быть открыты для расширения, но закрыты для модификации.» ©Википедия
* * * - Классы должны быть открыты для расширения, но закрыты для изменения. ©Head First
* * *
* * * Большинство примеров по этому принципу сводят к одной мысли - что чаще всего данный принцип используется:
* * * Если есть метод, какой может иметь несколько реализаций, то нужно создать абстрактный класс или интерфейс, от него
* * * наследоваться и создать несколько реализаций метода, после чего в классе метода, ради которого вся эта работа и
* * * происходит получить ссылку на нужный класс, какой вызовет нужную реализацию.
* * *
* * * Класс станет использовать абстрактный класс или интерфейс и не будет зависить от конкретной реализации.
* * * Конкретная реализация будет передаваться по ссылке, какая может сохранится в поле класса и использоваться
* * * для вызова конкретной реализации.
* * *
* * * Используется, когда классом какой нужно изменить уже кто-то пользуется, поэтому его нужно открыть для расширений,
* * * и закрыть для изменений. Чаще всего такое происходит уже в проектах, какие показали себя уже в некой стадии, и
* * * нельзя гарантировать что если мы изменим класс, то ни у кого никакой код не пострадает и даже тесты будут
* * * работать исправно. Также нужно учитывать, что в готовом проекте уже скорее всего есть тесты на разные классы,
* * * поэтому если даже есть гарантия что этим классом никто не пользуется, то не факт что тесты после его изменения
* * * будут работать исправно.
* * *
* * * Для просмотра примера кода сюда (Пример на PHP) : https://habrahabr.ru/post/208442/
*
* Принцип подстановки Барбары Лисков (Liskov substitution principle)
* * * - «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности
* * *   выполнения программы.» ©Википедия
* * *
* * * Суть принципа в том, чтобы при замене с родительского класса на дочерний, ничего не приходилось менять. Все
* * * дочерние классы должны быть ортогональны по отношению к родительскому классу.
* * *
* * * Имееться ввиду, если есть класс А, от него наследуется класс В. И если при использовании класса А в каком нибудь
* * * месте, я заменю его на класс В - всё должно работать без изменений в коде. И это относится не только к классам,
* * * а ко всему что имеет иерархическую связь с чем-либо.
*
* Принцип разделения интерфейса (Interface segregation principle)
* * * - «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс
* * *   общего назначения.» ©Википедия
* * *
* * * Главная цель принципа, создавать интерфейсы с узкой специализацией. Тоже самое что с первым принципом
* * * единственной обязанности, только с интерфейсами.
* * *
* * * Интерфейс, должен содержать методы какие связывают только одну функциональность.
* * *
* * * Пробуйте создавать абстракции, какие должны быть между собой ортогональны (независимыми) и маленькими. ©Головач
*
* Принцип инверсии зависимостей (Dependency inversion principle)
* * * - «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.» ©Википедия
* * *
* * * Принцип работает следующим образом. Когда например один класс вызывает в себе методы другого класса, то
* * * таким образом проявляется явная зависимость классов.
* * *
* * * Например. Есть класс А и класс В. Класс А использует в себе методы класса В. И из-за этого они явно зависят от
* * * друг друга. Если изменить сигнатуру какого-то метода в классе В. То данное исправление сразу же нужно будет
* * * применить и в классе А.
* * *
* * * Решить такую проблему можно используя абстракцию. И зависит только от неё.
* * *
* * * Например. Есть несколько человек в проекте, какие разделили свою разработку над проектом. Один создает
* * * контроллеры, а другой представление. То эти люди могут создать общий интерфейс, согласовать подробно сигнатуру
* * * каждого требуемого метода и вдвоем использовать этот интерфейс. Таким образом, они вдвоем будут зависить
* * * от согласованной абстракции, к какой нужно находить подход и писать код для неё.
* * *
* * * После такого подхода класс А может смело получать ссылку класса какой реализует согласованный интерфейс,
* * * и вызывать от туда методы.
*
* PRINCIPLES OF PACKAGE COHESION
* * * * * * * * * * * * * * * *
*
* Принцип эквивалентности повторного приминения (Release Reuse Equivalency Principle)
* * * - Уровень детализации должен соответствовать желаемому уровню детализации новой версии.
* * *
* * * Как я понял с лекции Головача.
* * * Принцип гласит, если ты изменяешь один класс, и тебе сразу же нужно менять другой класс, то они взаимосвязаны,
* * * и должны лежать в одном джарнике.
*
* PRINCIPLES OF PACKAGE COUPLING
* * * * * * * * * * * * * * * *
*
* The acyclic dependencies principle
* * *
* * * Как я понял с лекции Головача.
* * * Есть класс А и класс В. Например класс А использует в методе f класс B, а класс В в методе g использует класс А.
* * * Таким образом при упаковке таких классов появляется циклическая зависимость.
* * * Желательно такие классы упаковывать вместе в один джарник.
*
* ДОП. СОВЕТЫ
* * * * * * *
*
* - Желательно пытаться по максимуму избавляться от сеттеров и пытаться начальные настройки делать с помощью
* * * конструктора.
*
* - После модификации кода может возникнуть ощущение, что из-за него система стала работать медленнее. Не нужно спешить
* * * с выводами и стоит Очень тщательно пересмотреть всю систему. (Часто система может тормозить из-за базы данных.)
*
* - Когда появляется необходимость добавить код, какой уже есть в другом месте и остается выход только скопировать код,
* * * то необходимо написать, что "вот этот код скопирован с 'того' метода".
* * *
* * * Если появляется необходимость скопировать код третий раз, то у вас появилась какая-то закономерность
* * * и нужно этот код переписать, убрав полностью дублирование.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * PRINCIPLES * * * * * * * * * * * * * * * * * * * * * * * * * * *