* * * * * * * * * * * * * * * * * * * * * * * * ПОЛЕЗНОСТИ/СОВЕТЫ * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WEB-INF - это внутренняя директория tomcat-а, и в случае, если попыться через url, зайти в какой-то файл в папке
* * * WEB-INF, то tomcat заблокирует доступ. Все родительские папки доступны и к их файлам можно обратиться через url,
* * * поэтому, в случае, если есть файлы содержающие пароли и т.д., то необходимо их ложить внутрь папки WEB-INF.
*
* Для работы с интерфейсом Filter приходиться всегда переопределять все его методы для реализации своего фильтра.
* * * Чтобы немного упростить себе задачу, можно создать абстратный класс BaseFilter, какой будет себя разширять с
* * * помощью как раз этого интерфейса Filter. Таким образом при создании своего фильтра можно унаследоваться от класса
* * * BaseFilter и после переопределять в свой класс только нужные методы.
* * * Также, можно в базовом абстрактном классе фильтра создать абстрактный метод doFilter, какой будет в точности как
* * * метод doFilter() с интерфейса Filter, только в базовом методе сделать приведение всех типов ServletRequest и
* * * ServletResponse, к более точным: HttpServletRequest, HttpServletResponse, и в нем вызвать абстраткный метод
* * * doFilter(). (Использование таких правил считается хорошим стилем программирования.)
* * * Выглядит это так:
* * *  @Override
* * *  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
* * *      doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);
* * *  }
* * *
* * *  public abstract void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException;
*
* Servlets - это реализация шаблона проектирования MVC.
* * * Servlet - это контроллер (controller), JSP - визуальное представление (view).
*
* RequestDispatcher, это класс какой говорит куда направится дальше, передать путь другому сервлету или просто задать
* * * путь на какой-то jsp-файл. Этот класс прежде всего обращается к web.xml. Оттуда считывает данные и относительно
* * * заданного пути передает работу другой вьюхе или контроллеру.
* * * Подробнее:
* * * // Переменной page присваиваем путь к нужному файлу.
* * * RequestDispatcher page = request.getRequestDispatcher("a/b/c.jsp");
* * * // После вызываем метод для перехода к этому файлу.
* * * page.forward(request, response);
* * *
* * * После вызова метода forward класса RequestDispatcher категорически не рекомендуется снова обращаться к параметрам
* * * текущего метода doFilter(): request и response.
*
* request - от него можно получить только данные какие приходят от клиента.
*
* response - передача информации клиенту.
*
* response.sendError(<Номер ошибки>); // сгенерировать ошибку под нужным номером, к примеру: 404.
*
* response.sendRedirect("<путь к фвйлу, к какому нужно перенаправить клиента>");
* * * Также, этот вызов пересикает границы контейнера. При вызове он генерирует ответ браузеру "302" и просит
* * * перенаправить клиента на нужный url. (И браузер относится к осторожностью к редиректам)
*
* Через всю цепочку фильтров и сервлетов всегда идет одна и та же пара request, response. Таким образом, если мы
* * * передадим например какой-нибудь атрибут, то после перехода к другим фильтрам или сервлету мы можем к нему
* * * обратиться.
*
* Если в web.xml внутри тега servlet, filter или listener внести тег load-on-startup, этот тег будет отвечать за очередь
* * * создания данного сервлета, фильтра или листенера во время подъема приложения.
* * * (Чем число меньше, тем раньше будет создан.)
*
* Все параметры в методах сервлета (doGet) при получении нужно присваивать значения локальным переменным.
* * * Это объясняется тем, что если в этот метод обратится несколько потоков сразу, мы можем перепутать данные.
* * * Но если присвоем сразу данные локальным переменным, то мы после сможем оперировать данными.
*
* В методе doGet настоятельно не рекомендуется делать мутирующие поля, имеется в виду, чтобы глобальные переменные
* * * не меняли себя в методе doGet. Опять же это из-за того, что к методу могут обращаться сразу несколько потоков.
*
* В jsp у нас по умолчанию уже имеется request (request, какой попал на страницу). Имеется ввиду, что в jsp можно
* * * обращаться к переменной request без её объявления. (Но это можно делать только через скриплеты, а скриплеты
* * * считаются плохой практикой.) Можно использовать аттрибуты. Передать их в сервлете и использовать с помощью ${...}.
* * * Синтаксис такой: имяАттрибута.геттер.ещёОдинГеттер.иМожетБытьЕщёОдинГеттер();
* * *
* * * Аттрибут это как бы последовательность 4-ех запросов. Он спрашивает последовательно у 4-ех уровней памяти.
* * * Если не находит у самого низкого продвигается выше и спрашивает там и т.д.
*
* Также думаю стоит знать что есть что-то наподобии 4-ех уровней памяти в сервлетах, какие можно успользовать.
* * * Уровни:
* * * 1. page - текущая страница, на какой находится пользователь.
* * * 2. request - запрос какой пришел. Он мог пройти несколько страниц и фильтров, смотря как перенаправили.
* * * 3. session - сессия пользователя.
* * * 4. servletContext - экземлпяр томкета. Другими словами это всё приложение.
* * *
* * * Таким образом у нас получается некая иерархия. Если это приставить в виде захватывающих кругов.
* * * То servletContext самый большой и он захватывает page, request и session, а page самый маленький и он находится
* * * внутри других уровней. Также, в request-е может быть несколько page, в session несколько request, а в
* * * servletContext несколько session. Одна сессия = один пользователь.
* * *
* * * Эти уровни сессии можно сохранить и передавать в jsp с помощью аттрибутов например.
*
* Скриплеты
* * * Когда пишем <%= ... > - тут должна содержаться строчка на java, какая должна вернуть какой-нибудь результат.
* * * Когда пишем <% ... > - любая операция какая не возвращает результат. Например присвоение чего-либо к чему-либо
* * * (писать можно бесконечно).
* * *
* * * Также в обычных скриплетах, нужно использовать вместо ">" - "gt", "<" - "lt".
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *