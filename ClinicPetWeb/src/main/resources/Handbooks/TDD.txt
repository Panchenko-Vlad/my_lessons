* * * * * * * * * * * * * * * * * * * * * * * TEST DRIVEN DEVELOPMENT * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Каждый класс теста называется - Test Case
*
* В реальной жизни (чаще всего) вначале пишется пустой метод, после пишутся все примитивные проверки на этот метод.
* * * Вначале, так как метод пустой, все эти тесты будут проваливаться. Но это делается с целью постепенно заполнять
* * * метод кодом и поочередно исправлять тесты.
*
* Тесты никаких аргументов не получают и ничего не возвращают.
*
* В TDD можно нарушать все правила наименования методов. Главное чтобы имя было говорящее что это за тест
* * * и что он делает.
*
* Над классов можно объявить аннотацию @RunWith() и в скобках прописать runner, какой будет тестировать данный класс.    @RunWith
* * * Внести в данную аннотацию можно любой класс какой является потомком Runner. В самом JUnit имеется кучу runner-ов,
* * * помимо этого можно найти в интернете доп. runner-ы. С помощью них можно расширить тестирование. Например, если с
* * * runner-ом будет аннотация, какую запустить n потоков в один метод. Таким образом можно будет проверять прогу на
* * * многопоточность.
* * *
* * * Например:
* * * * * @RunWith(JUnit4.class)
*
* В тестах есть специальное исключение, какое используется                                                               AssertionError
* * * когда мы должны вызвать искуственную ошибку в тесте и
* * * дать знать что тест работает не по правилам.
* * * Исключение - AssertionError();
*
* JUnit для каждого вызова метода создает новый экземпляр test case. Из-за этого можно спокойно создавать поля           Static field
* * * в test case. Но естественно нежелательно создавать статические поля. Если метод провалиться, в переменной могут
* * * остаться нежелательные данные. Также, из-за создания экземпляра каждый раз, каждый раз и вызывается конструктор
* * * класса (если он объявлен). Он вызывается после аннотации @BeforeClass и он должен быть без параметров.
*
* Обозначение аннотаций в тестах:                                                                                        Annotation
* * * @BeforeClass - запуститься самым первым и только один раз.                (Должен быть public static)
* * * * * (Полезно инициализировать переменные, а объявлять их в полях класса)
* * * @Before - будет запускаться перед вызовом каждого тестового метода.       (Должен быть public)
* * * @Test - обозначение тестового метода.                                     (Должен быть public)
* * * * * @Test(expected = "someNameException",  // Какое исключение ожидается при успешном выполнении теста.
* * * * *       timeout = "someTime");           // Максимальное время работы метода в миллисекундах. После тест падает.
* * * @After - будет запускаться после каждого тестового метода.                (Должен быть public)
* * * @AfterClass - запуститься самым последним и только один раз.              (Должен быть public static)
* * * @Ignore - данный тест не будет проверяться.
*
* external DSL - когда в программу внедряется код, какой написан на другом ЯП. Это делается для того, чтобы сократить    external DSL
* * * время разработки и количество кода. Так как что-то можно реализовать проще на другом языке, чем писать много
* * * сложного кода на основном языке.
*
* internal DSL - внедряется в основной язык, что имеет свой собственный стиль написания кода, но сама состоит из         internal DSL
* * * основного языка и полностью подчиняется его правилам.
* * *
* * * JUnit является internal DSL. Так как у него содержится полностью собственный стиль написания кода.
*
* Проще работать с internal dsl, библиотекой под названием FEST Fluent Assertions, чем с JUnit. Эта библиотека           Assertions
* * * упрощает написание тестов и очень похожа на JUnit.
*
* Matcher - это предикат
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *