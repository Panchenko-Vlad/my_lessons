* * * * * * * * * * * * * * * * * * * * * * * TEST DRIVEN DEVELOPMENT * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Каждый класс теста называется - Test Case
*
* В реальной жизни (чаще всего) вначале пишется пустой метод, после пишутся все примитивные проверки на этот метод.
* * * Вначале, так как метод пустой, все эти тесты будут проваливаться. Но это делается с целью постепенно заполнять
* * * метод кодом и поочередно исправлять тесты.
*
* Тесты никаких аргументов не получают и ничего не возвращают.
*
* В TDD можно нарушать все правила наименования методов. Главное чтобы имя было говорящее что это за тест
* * * и что он делает.
*
* Над классов можно объявить аннотацию @RunWith() и в скобках прописать runner, какой будет тестировать данный класс.    @RunWith
* * * Внести в данную аннотацию можно любой класс какой является потомком Runner. В самом JUnit имеется кучу runner-ов,
* * * помимо этого можно найти в интернете доп. runner-ы. С помощью них можно расширить тестирование. Например, если с
* * * runner-ом будет аннотация, какую запустить n потоков в один метод. Таким образом можно будет проверять прогу на
* * * многопоточность.
* * *
* * * Например:
* * * * * @RunWith(JUnit4.class)
*
* В тестах есть специальное исключение, какое используется                                                               AssertionError
* * * когда мы должны вызвать искуственную ошибку в тесте и
* * * дать знать что тест работает не по правилам.
* * * Исключение - AssertionError();
*
* JUnit для каждого вызова метода создает новый экземпляр test case. Из-за этого можно спокойно создавать поля           Static field
* * * в test case. Но естественно нежелательно создавать статические поля. Если метод провалиться, в переменной могут
* * * остаться нежелательные данные. Также, из-за создания экземпляра каждый раз, каждый раз и вызывается конструктор
* * * класса (если он объявлен). Он вызывается после аннотации @BeforeClass и он должен быть без параметров.
*
* Обозначение аннотаций в тестах:                                                                                        Annotation
* * * @BeforeClass - запуститься самым первым и только один раз.                (Должен быть public static)
* * * * * (Полезно инициализировать переменные, а объявлять их в полях класса)
* * * @Before - будет запускаться перед вызовом каждого тестового метода.       (Должен быть public)
* * * @Test - обозначение тестового метода.                                     (Должен быть public)
* * * * * @Test(expected = "someNameException",  // Какое исключение ожидается при успешном выполнении теста.
* * * * *       timeout = "someTime");           // Максимальное время работы метода в миллисекундах. После тест падает.
* * * @After - будет запускаться после каждого тестового метода.                (Должен быть public)
* * * @AfterClass - запуститься самым последним и только один раз.              (Должен быть public static)
* * * @Ignore - данный тест не будет проверяться.
*
* external DSL - когда в программу внедряется код, какой написан на другом ЯП. Это делается для того, чтобы сократить    external DSL
* * * время разработки и количество кода. Так как что-то можно реализовать проще на другом языке, чем писать много
* * * сложного кода на основном языке.
*
* internal DSL - внедряется в основной язык, что имеет свой собственный стиль написания кода, но сама состоит из         internal DSL
* * * основного языка и полностью подчиняется его правилам.
* * *
* * * JUnit является internal DSL. Так как у него содержится полностью собственный стиль написания кода.
*
* Проще работать с internal dsl, библиотекой под названием FEST Fluent Assertions, чем с JUnit. Эта библиотека           Assertions
* * * упрощает написание тестов и очень похожа на JUnit.
*
* Matcher - это предикат
*
* В тестах обязательно должно быть три секции. Это правило относится также к ОО-дизайну (OOD).
* * * 1. Назначение переменных
* * * 2. Действия
* * * 3. Проверка вычислений (assert)
*
* MOCKITO
* * * * *
*
* Хорошая официальная документация к mockito: http://site.mockito.org/mockito/docs/1.10.19/org/mockito/Mockito.html#3
*
* При создании мока создается пустой экземпляр класса с пустыми методами и дефолтными возвращениями.
* * * Это может пригодиться, когда нужен экземпляр, а его реализация не очень важна. Когда мы будем вызывать
* * * какой-нибудь метод из этого класса, мы вручную будем указывать с помощью Mockito, что должен вернуть метод
* * * То есть, мы создадим сценарий, по какому вручную скажем что должен вернуть метод и протестируем его.
* * * Следовательно, когда необходима реализация, не следует создавать мок.
* * *
* * * Пример:
* * * * * MyClass myClass = mock(MyClass.class); // Пустой экземпляр класса
* * * * * MyClass myClass = new MyClass(); // Обычный экземпляр класса
*
* Чтобы вернуть искуственно значение в методе, нужно сделать следующее:
* * * when(<Метод>).thenReturn(<Что он должен вернуть>); // Также может быть thenThrow, чтобы вернуть исключение
* * *
* * * Когда передаваемый метод возвращает void предыдущий пример работать не будет, вместо него нужно использовать:
* * * * * // Кидаем исключение, когда вызывается метод clear() класса List
* * * * * doThrow(new RuntimeException()).when(mockedList).clear();
*
* По умолчанию последовательность проверок с помощью verify не проверяется. Чтобы это исправить,
* * * нужно сделать следующее:
* * * * *
* * * * * // Проверка одного мока
* * * * * List singleMock = mock(List.class); // Создаем мок класса, какой нужно нам проверить
* * * * *
* * * * * singleMock.add("was added first"); // Вызываем методы в нужной последовательности
* * * * * singleMock.add("was added second");
* * * * *
* * * * * InOrder inOrder = inOrder(singleMock); // Создаем класс, какой будет проверять последовательность вызовов
* * * * *
* * * * * inOrder.verify(singleMock).add("was added first"); // Вызываем и проверяем методы в нужной последовательности
* * * * * inOrder.verify(singleMock).add("was added second");
* * * * *
* * * * * // Проверка двух моков
* * * * * List firstMock = mock(List.class); // Тоже самое, но создаем два класса для проверки
* * * * * List secondMock = mock(List.class);
* * * * *
* * * * * firstMock.add("was called first"); // Вызываем их методы в нужной последовательности
* * * * * secondMock.add("was called second");
* * * * *
* * * * * InOrder inOrder = inOrder(firstMock, secondMock); // Вносим классы, у каких нужно проверять последовательность
* * * * *
* * * * * inOrder.verify(firstMock).add("was called first");
* * * * * inOrder.verify(secondMock).add("was called second");
*
* По терминологии mockito:
* * * mock - внесение интерфейса и создание какого-то экземпляра для него
* * * * * MyInterface instance = mock(MyInterface.class);
* * * stub - внесение класса и скорее всего полноценное создание экземпляра этого класса
* * * * * MyClass instance = mock(MyClass.class);
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *