* * * * * * * * * * * * * * * * * * * * * * * * * * SPRING FRAMEWORK * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Spring IoC DI
* * * * * * * * * * *
*
* XML
* * *
*
* Чтобы спринг создал объект класса, нужно в спринговой xml внутри тега beans внести:                                    bean

<bean id="<уникальное имя> class="<полный пакет класса>" >
    <constructor-arg value="<аргумент конструктора>" /> <!-- В случае, если отсутствует конструктор без аргументов -->
    <constructor-arg value="<ещё один аргумент>" /> <!-- Если, аргументов несколько. Тип определяется автоматически -->

    <!-- Если, аргументов много, можно использовать аттрибуты для указания имени или индекса параметра конструктора -->
    <constructor-arg name="<имя параметра>" value="<ещё один аргумент>" />
    <constructor-arg index="<номер параметра (начало с 0)>" value="<ещё один аргумент>" />

    <!-- Можно использовать аттрибут для указания типа аргумента конструктора -->
    <constructor-arg name="<имя параметра>" type="<примитивный тип>" value="<ещё один аргумент>" />
    <constructor-arg name="<имя параметра>" type="<полный путь, если тип не примитивный>" value="<ещё один аргумент>" />
</bean>

* В случае, если у нас имеется бин, какой является синглтоном, то при объявлении в xml-файле мы должны указать           factory-method
* * * фабричным метод, какой собественно будет создавать и возвращать экземпляр объекта.

<bean id="<уникальное имя>" class="<полный пакет класса>" factory-method="<имя метода>" />

* Если фабричный метод находится в другом классе, то для этого есть специальный аттрибут factory-bean:                   factory-bean

<!-- В первом бине мы указали класс, в каком находится фабричный метод, какой вернет экземпляр этого бина -->
<bean id="unique_name1" class="ru.clinicPetWeb.store" factory-method="getInstance" factory-bean="unique_name2" />
<bean id="unique_name2" class="ru.clinicPetWeb.tools" />

* Если есть необходимость сразу в xml-файле задать значения свойствам класса,                                            property
* * * можно это сделать с помощью тега property:

<bean id="<уникальное имя>" class="<полный пакет класса>" >
    <property name="<имя свойства класса> value="<значение свойства класса>" />
</bean>

* В случае, если у свойства класса не примитивный тип, то на помощь приходит аттрибут ref:                               ref

<bean id="<уникальное имя>" class="<полный пакет класса>" >
    <!-- Таким образом, свойству будет присвоен данный бин -->
    <property name="<имя свойства класса> ref="<уникальное имя, какого-то бина>" />
</bean>

* Так как в случае, описанном выше мы присваиваем внешний бин свойству класса, можно предположить
* * * что в некоторых случаях данный класс нигде больше не будет использовать. И чтобы последнего не вызвали в runner-е
* * * с помощью getBean();. Можно данный бин сделать внутренним и объявить его внутри тега property:

<bean id="<уникальное имя>" class="<полный пакет класса>" >
    <!-- Таким образом, свойству будет присвоен данный бин -->
    <property name="<имя свойства класса> ref="<уникальное имя, какого-то бина>">
        <bean id="<уникальное имя2>" class="<полный пакет класса>" />
    </property>
</bean>

* Если необходимо внести значения в свойство класса, какое имеет тип коллекции, то выполнить это можно                   List
* * * следующим образом:

<bean id="<уникальное имя>" class="<полный пакет класса>" >

    <!-- В данном случае у нас пример для List<String> -->
    <property name="<имя свойства класса>" >
        <list>
            <value>value 1</value>
            <value>value 2</value>
            <value>value 3</value>
        </list>
    </property>

    <!-- Если имеется List<Object>, то место тега value, можно смело использовать тег bean в любом кол-ве -->
    <property name="<имя свойства класса>" >
        <list>
            <bean id="name1" class"somePath" />
            <bean id="name2" class"somePath" />
            <bean id="name3" class"somePath" >
                <constructor-arg name="<parameter1>" type="String" value="<value1>" />
            </bean>
        </list>
    </property>

    <!-- В случае, если бин уже объявлен в xml, то можно использовать тег ref, внутри которого написать id бина -->
    <property name="<имя свойства класса>" >
        <list>
            <ref>nameId1</ref>
            <ref>nameId2</ref>
            <ref>nameId3</ref>
        </list>
    </property>

    <!-- Чтобы использовать коллекцию Set, аналогично нужно использовать тег set вместо list -->
    <property name="<имя свойства класса>" >
        <set>
            <value>value 1</value>
        </set>
    </property>

    <!-- Если коллекция Map, то нужно использовать тег map -->
    <property name="<имя свойства класса>" >
        <map>
            <entry key="<номер ключа>" value="<значение>" />
            <entry key="<номер ключа>" value="<значение>" />
            <entry key="<номер ключа>" value="<значение>" />
        </map>
    </property>

    <!-- Если коллекция не примитивных типов, то делать нужно следующее: -->
    <property name="<имя свойства класса>" >
        <map>
            <entry>
                <key>1</key>
                <value>
                     <bean id="name1" class"somePath" />
                </value>
            </entry>
            <entry>
                <key>2</key>
                <value>
                     <ref>nameId1</ref>
                </value>
            </entry>
            <entry>
                <key><bean id="name3" class"somePath" /></key>
                <value>value1</value>
            </entry>
        </map>
    </property>
</bean>

* Если в классе есть метод, какой инициализирует необходимые данные при создании класса или что-то подобное, то
* * * то для этого есть специальный аттрибут init-method, какой вызовет данный метод, после полной подгрузки
* * * всех параметров конструктора и самого конструктора. Также соответсвенно, есть аттрибут destroy-method,
* * * какой выполняет закрытие всех ресурсов, то бишь метод какой будет вызван при уничтожении класса.

<bean id="name1" class="somePath" init-method="name_method" destroy-method="destroy" />

* Если необходимо изменить id бина, это можно сделать с помощью тега alias:

<bean id="name1" class"somePath" />

<alias name="name1" alias="new_name1" /> <!-- После такого изменения, мы можем обращаться как name1 так и new_name1 -->

* При подгрузке xml-файла, когда мы инициализаруем ApplicationContext, все бины и все данные начнут инициализироваться
* * * если появилась необходимость, чтобы какой-то бин не создавался, нужно написать аттрибут lazy-init="true".

<bean id="name1" class"somePath" lazy-init="true" />

* Получение конкретного объекта в runner-е спринга:                                                                      ApplicationContext

ApplicationContext context = new ClassPathXmlApplicationContext("spring-context.xml");
MyInterface bean = (MyInterface) context.getBean("<уникальное имя, какое было присвоено в xml-файле>");

*
* АННОТАЦИИ
* * * * * *
*
*
*
* ОСТАЛЬНОЕ
* * * * * *
*
* У ApplicationContext есть несколько реализации, вот предназначение нескольких из них:
* * * ClassPathXmlApplicationContext - когда конфигурируемый спрингом xml-файл находится в папке с нашим проектом.
* * * FileSystemXmlApplicationContext - если конфигурируемый спрингом xml-файл находится на стороне, вне проекта.
* * * XmlWebApplicationContext - если конфигурируемый спрингом xml-файл находится на каком-то веб-сервере.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * SPRING FRAMEWORK * * * * * * * * * * * * * * * * * * * * * * * * *