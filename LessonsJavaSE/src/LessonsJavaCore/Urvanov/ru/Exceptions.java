package LessonsJavaCore.Urvanov.ru;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * Исключение (exception) - это событие, которое возникает во время выполнения программы и прерывает нормальный
 * * * поток выполнения инструкций.
 * * *
 * * * Когда возникает какая-нибудь ошибка внутри метода, метод создаёт специальный объект, называемый
 * * * объектом-исключением или просто исключением (exception object), который передаётся системе выполнения.
 * * * Этот объект содержит информацию об ошибке, включая тип ошибки и состояние программы, в котором произошла ошибка.
 * * * Создание объекта-исключения и передача его системе выполнения называется броском исключения
 * * * (throwing an exception).
 * * *
 * * * После бросания исключения система пытается найти его обработчик. Система выполнения проходит по стеку вызовов
 * * * от текущего метода вверх, ища подходящий обработчик исключений.
 * * *
 * * * Выбранный обработчик исключения ловит это исключение.
 * * *
 * * * Если системе не удаётся найти подходящий обработчик исключения, то программа завершает своё выполнение.        *
 *
 * В Java все классы-исключения являются наследниками от класса java.lang.Throwable, который в свою очередь имеет
 * * * подклассы java.lang.Error и java.lang.Exception. Класс java.lang.Exception имеет дочерний класс
 * * * java.lang.RuntimeException.
 * * *
 * * * Согласно соглашению все бросаемые исключения являются наследниками трёх классов: java.lang.Error,
 * * * java.lang.Exception или java.lang.RuntimeException. Технически можно бросить исключение, которое не является
 * * * наследником этих трёх классов, но является наследником java.lang.Throwable, но так делать не принято.
 */

/**
 * Виды исключений в Java 8                                                                                           *
 * - Наследники java.lang.Error. Эти исключения возникают при серьёзных ошибках, после которых невозможно нормальное
 *   продолжение выполнения программы. Это могут быть различные сбои аппаратуры и т. д. В обычных ситуациях ваш код
 *   не должен перехватывать и обрабатывать этот вид исключений.
 *
 * - Наследники java.lang.RuntimeException. Это непроверяемый тип исключений вроде выхода за границу массива или
 *   строки, попытка обращения к методу на переменной, которая содержит null, неправильное использование API и т.д.
 *   В большинстве своём программа не может ожидать подобные ошибки и не может восстановиться после них. Подобные
 *   исключения возникают из-за ошибок программиста. Приложения может их перехватывать, но в большинстве случаев имеет
 *   гораздо больше смысла исправить ошибку, приводящую к подобным исключениям.
 *
 * - Наследники java.lang.Exception, которые НЕ являются наследниками java.lang.RuntimeException. Подобный тип
 *   исключений называется проверяемыми исключениями (checked exceptions). Это такой тип исключений, который может
 *   ожидать хорошо написанная программа, и из которых она может восстановить свой обычный ход выполнения. Это может
 *   быть попытка открыть файл, к которому нет доступа, или которого не существует, проблемы с доступом по сети и т.д.
 *   Все исключения являются проверяемыми, кроме наследников java.lang.Error и java.lang.RuntimeException.
 *   Любой метод, который может бросить проверяемое исключение, должен указать это исключение в клаузе throws.
 *   Для любого кода, который может бросить проверяемое исключение, это исключение должно быть указано в throws метода,
 *   либо должно быть перехвачено с помощью инструкции try-catch.
 */

/**
 * Начиная с Java 7 можно в одном блоке catch  перехватывать несколько различных типов исключений, что позволяет
 * * * уменьшить количество кода:
 * * * * * catch (IOException|SQLException ex) {
 * * * * *     logger.log(ex);
 * * * * *     // ... other code
 * * * * * }
 * * * Если блок catch  перехватывает несколько типов исключений, то тогда его параметр неявно final, то есть в
 * * * примере выше вы не можете присвоить параметру ex  что-либо в блоке catch.
 */

/**
 * Посмотрим на фрагмент кода из примера:                                                                             *
 * * * OutputStream os = new FileOutputStream("output.file");
 * * * os.write(bytesToWrite);
 * * * os.close();
 * * *
 * * * Последняя строка os.close() закрывает файл и освобождает ресурсы системы. Но она сработает только при
 * * * нормальном ходе выполнения программы. Если какое-нибудь исключение возникнет в конструкторе или в методе
 * * * write(), то метод закрытия потока не выполнится, а значит будет утечка ресурсов.
 * * *
 * * * Чтобы избежать подобных проблем освобождение ресурсов нужно осуществлять в блоке finally. Код в блоке finally
 * * * выполняется ВСЕГДА после завершения блока try, даже в случае возникновения исключения. (Желательно спрашивать,
 * * * нужно ли закрывать файл и освобождать ресурсы. Является ли переменная null, если нет, то освобождаем русурсы.)
 */

/**
 * Если виртуальная машина Java завершит своё выполнение во время выполнения кода try или catch, то блок finally      *
 * * * может НЕ выполниться. Так же если поток будет прерван внутри кода try или catch, то блок finally может
 * * * НЕ выполниться, хотя программа продолжит своё выполнение.
 */

/**
 * Приведённый выше код можно сделать более понятным, если использовать оператор try-with-resources.                  *
 * * * Любой объект, который реализует интерфейс java.lang.AutoCloseable, который включает все объекты, который
 * * * реализуют java.io.Closeable (Closeable расширяет AutoCloseable), например FileOutputStream, можно использовать
 * * * в try-with-resources:
 */
 class TryWithResources {
     public static void main(String[] args) {
         byte[] bytesToWrite = new byte[100];

         try (OutputStream os = new FileOutputStream("output.file")) { // try-with-resources
             os.write(bytesToWrite);
             System.out.println("end try");
         } catch (FileNotFoundException fnfe) {
             System.out.println("Cannot find the file.");
         } catch (IOException ioex) {
             System.out.println("Error writing file: " + ioex.getMessage());
         }
         // Блок finally уже не нужен, но можно использовать, если хочется.

         System.out.println("End of program.");
     }
 }
/**
 * * * В этом примере try-with-resources автоматически вызовет метод close(), что освободит ресурсы.
 */

/**
 * В блоке try-with-resources можно указывать несколько ресурсов, тогда они будут открываться слева направо,
 * * * как указано в блоке, а закрываться справа налево (то есть в обратном порядке):
 * * * * * try (OutputStream os = new FileOutputStream("output.file");
 * * * * *      FileReader fr = new FileReader("input.txt")) {
 * * * * *     // ...
 * * * * * }
 */

/**
 * Блок try-with-resources может не иметь ни секции catch, ни finally, но обычный блок try должен обязательно         *
 * * * иметь либо секцию catch, либо секцию finally, либо обе секции.
 */

/**
 * Ресурсы блока try-with-resources закрываются перед выполнением блоков catch и finally.
 */

/**
 * Рассмотрите следующий код:
 * * * static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException {
 * * *     BufferedReader br = new BufferedReader(new FileReader(path));
 * * *     try {
 * * *         return br.readLine();
 * * *     } finally {
 * * *         if (br != null) br.close();
 * * *     }
 * * * }
 * * *
 * * * Если метод readLine() бросит исключение, а затем метод close() тоже бросит исключение, то метод
 * * * readFirstLineFromFileWithFinallyBlock() бросит исключение из блока finally, а исключение из блока try будет
 * * * подавлено.
 *
 * Если же исключение возникнет в блоке try и в блоке освобождающем ресурсы для try-with-resources, то конечное
 * * * исключение, бросаемое методом будет исключение из блока try, то есть исходное. Это ещё одно преимущество
 * * * использования try-with-resources. Исключения, которые были подавлены в блоке try-with-resources можно получить
 * * * с помощью метода public final Throwable[] getSuppressed().
 */

/**
 * Метод close() в интерфейсе java.lang.AutoCloseable объявляет в клаузе throws исключение Exception, а метод close()
 * * * в java.io.Closeable объявляет IOException, что позволяет наследникам AutoCloseable определять свои, специфичные
 * * * для своей области исключения.
 */

/**
 * Указание типов исключений, бросаемых методом
 * * * Если какой-нибудь код внутри метода может бросать проверяемые исключения, то эти исключения должны либо
 * * * перехватываться и обрабатываться внутри метода, либо метод должен указывать, что он может бросить исключение
 * * * подобного вида с помощью ключевого слова throws:
 */
 class WildWorld {
     public void someCalculation(int arg1, double arg2)
             throws java.io.IOException, java.sql.SQLException,
             java.lang.IndexOutOfBoundsException {
     }
 }
/**
 * * * Исключение IndexOutOfBoundsException является наследником RuntimeException, поэтому указывать его
 * * * не обязательно и даже не нужно.
 */

/**
 * Как бросить исключение
 * * * Перед тем как вы сможете перехватить исключение, какой-нибудь код должен его бросить/сгенерировать.
 * * * Любой код может бросить исключение: ваш код, код из пакета, написанного кем-то другим, сама среда Java.
 * * * Исключение всегда бросается с помощью инструкции throw, независимо от того, кто его бросает:
 * * * * * if (x == 0)
 * * * * *     throw new IllegalStateException("Что-то пошло не так");
 */

/**
 * Цепочки исключений                                                                                                 *
 * * * Приложения часто отвечает на исключение бросанием другого исключения. Цепочки исключений позволяют узнать,
 * * * какое исключение привело к появлению другого исключения.
 * * *
 * * * Следующие методы и конструкторы класса java.lang.Throwable помогают работать с цепочками исключений:
 * * * * * Throwable getCause()
 * * * * * Throwable initCause(Throwable)
 * * * * * Throwable(String, Throwable)
 * * * * * Throwable(Throwable)
 * * *
 * * * Аргумент Throwable метода initCause и Throwable в конструкторах - это исключения, которые привели к текущему
 * * * исключению. Метод getCause() возвращает исключение, которое стало причиной текущего исключения, а метод
 * * * initCause устанавливает причину текущего исключения.
 * * *
 * * * Пример использования цепочки исключений:
 * * * * * try {
 * * * * *
 * * * * * } catch (IOException e) {
 * * * * *     throw new SampleException("Other IOException", e);
 * * * * * }
 * * * В этом примере при обработке исключения IOException создаётся новое исключение SampleException, а причина
 * * * этого исключения присоединяется к цепочке исключений, и цепочка исключений бросается в следующий уровень
 * * * обработчиков исключений.
 * * *
 * * * Если какой-нибудь код с верхнего уровня обработчиков исключений захочет вывести стек вызовов, то ему нужно     *
 * * * будет использовать метод getStackTrace():
 * * * * * catch (Exception cause) {
 * * * * *     StackTraceElement elements[] = cause.getStackTrace();
 * * * * *     for (int i = 0, n = elements.length; i < n; i++) {
 * * * * *         System.err.println(elements[i].getFileName()
 * * * * *             + ":" + elements[i].getLineNumber()
 * * * * *             + ">> "
 * * * * *             + elements[i].getMethodName() + "()");
 * * * * *     }
 * * * * * }
 */

/**
 * Создание своих объектов-исключений                                                                                 *
 * * * Когда вы выбираете исключение, которое будет бросать ваш код в какой-либо ситуации, вы можете выбрать
 * * * создание своего нового класса исключения.
 * * *
 * * * Вам следует написать свои собственные классы исключений, если вы ответите «Да» на любой из следующих вопросов,
 * * * в противном случае вам, вероятно, следует использовать какое-нибудь из существующих исключений:
 * * * - Вам нужно исключение типа, который не предоставлен платформой Java?
 * * * - Поможет ли это пользователям, если они смогут отличать ваши исключения от исключений, брошенных другими
 * * *   производителями?
 * * * - Бросает ли ваш код более одного связанного исключения?
 * * * - Если вы используете чьи-то другие исключения, то смогут ли пользователи получить доступ к этим исключениям?
 * * *   Или должен ли быть пакет независимым и самодостаточным?
 * * *
 * * * Согласно соглашению о кодировании в Java имена исключений должны заканчиваться на Exception.
 *
 * Пример возможного кода для исключения GameLogicException:
 */
 class GameLogicException extends Exception {

     // Конструкторы, вызывающие конструкторы базового класса.

     public GameLogicException() {
         super();
     }

     public GameLogicException(String message) {
         super(message);
     }

     public GameLogicException(String message, Throwable cause) {
         super(message, cause);
     }

     public GameLogicException(Throwable cause) {
         super(cause);
     }

     // остальные методы.
 }

/**
 * Преимущества исключений
 * * * 1. Разделение кода обработки ошибок от обычного кода.
 * * * 2. Распространение информации о произошедшей ошибке вверх по стеку вызовов.
 * * * 3. Группировка и разделение различных типов ошибок.
 */

public class Exceptions {
}
