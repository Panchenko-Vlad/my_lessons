# Java 8 потоки ввода/вывода
**Поток ввода/вывода (I/O Stream)** представляет собой источник данных или место их назначения. Потоки могут
представлять собой абсолютно различные источники и места назначения: файлы на дисках, устройства, сеть,
другие программы, массивы в памяти т. д.

Независимо от внутреннего устройства потоки представляют собой одинаковую модель для программы.
Поток представляет собой последовательность данных.

## Классы Java IO API
#### Базовые

- InputStream / OutputStream
- Reader / Writer
- InputStreamReader / OutputStreamWriter

#### Массивы

- ByteArrayInputStream / ByteArrayOutputStream
- CharArrayReader / CharArrayWriter

#### Файлы

- FileInputStream / FileOutputStream
- RandomAccessFile / RandomAccessFile
- FileReader / FileWriter

#### Буферизация

- BufferedInputStream / BufferedOutputStream
- BufferedReader / BufferedWriter

## Диаграмма классов, показывающая иерархию основных дочерних классов для класса `java.io.InputStream`
![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/LessonsJavaCore/IO/Screenshots/InputStream.png)

## Диаграмма классов, показывающая иерархию основных дочерних классов для класса `java.io.OutputStream`
![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/LessonsJavaCore/IO/Screenshots/OutputStream.png)

## Диаграмма классов, показывающая иерархию основных дочерних классов для `java.io.Reader`
![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/LessonsJavaCore/IO/Screenshots/Reader.png)

## Диаграмма классов, показывающая иерархию основных дочерних классов для `java.io.Writer`
![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/LessonsJavaCore/IO/Screenshots/Writer.png)

## Потоки байт
Все классы, работающие с потоками байт, наследуются от абстрактных классов `java.io.InputStream` или `java.io.OutputStream`.

#### java.io.InputStream - _абстрактный класс, являющийся базовым классом для всех классов, представляющий поток ввода._

### Основные методы:
**`public int available() throws IOException`**

Возвращает кол-во байт, которое может быть прочитано из потока без блокировки. Другими словами,
он возвращает кол-во байт какое сейчас мгновенно могут прочитать, для получения такого же кол-ва байт,
доступ на какое-то время блокируется и после возвращается такое же кол-во байт. Некоторые реализации
InputStream возвращают полное кол-во байт в потоке, но не все. Не стоит использовать этот метод для
определения размера буфера, который будет хранить все данные из потока.

Грубо говоря этот метод используется для определения размера буфера. Тот размер, какой вернет этот метод,
будет считываться мгновенно. Этот размер используется чтобы при чтении не происходило долгих ожиданий,
потому что система может затормозить и выбирать, считывать ей ещё данные или же вернуть сколько уже имеется.

**`public void close() throws IOException`**

Закрывает поток и освобождает все ресурсы.

**`public long skip(long n) throws IOException`**

Пропускает n следующих байт во входном потоке. Может пропустить меньшее количество байт по какой-нибудь
причине. Возвращается реальное количество пропущенных байт.

**`public boolean markSupported()`**

Возвращает true, если реализация InputStream поддерживает методы `mark()` и `reset()`.

**`public void mark(int readlimit)`**

Помечает текущую позицию во входной строке. Каким-то образом запоминает все считанные после вызова этого
метода данные и может вернуть те же самые данные ещё раз после вызова метода `reset()`. Если после вызова
метода `mark(int readLimit)` из потока было прочитано больше readLimit байт, то поток не обязан запоминать
что бы то ни было. Работает только если `markSupported()` возвращает true.

**`public void reset() throws IOException`**

Поток возвращается в такое состояние, что все вызовы методов `read()` в дальнейшем будут возвращать
те же данные, которые они возвращали с момента последнего вызова метода `mark()` (либо с начала потока,
если метод `mark()` не был вызван ни разу).

**`public abstract int read() throws IOException`**

Считывает один байт из потока. Возвращает его в int, содержащем значение от 0 до 255. Возвращает -1, 
если достигли конца потока. Блокирует выполнение текущего потока программы до тех пор, пока не появятся 
входные данные, не достигнется конец потока, либо бросится исключение.

**`public int read(byte[] b) throws IOException`**

Считывает некоторое количество байт из входного потока и сохраняет его в массив байт b. Возвращает 
количество считанных байт, которое может быть меньше длины массива. Метод блокирует выполнение 
текущего потока программы до тех пор, пока не появятся входные данные, не достигнется конец потока, 
либо бросится исключение.

Если длина массива b  равна нулю, то байты не считываются и возвращается 0, в противном случае 
происходит попытка считать хотя бы один байт. Если достигнут конец потока, то возвращается -1.

Метод `read(b)` у класса `InputStream` имеет такой же эффект, что и `read(b, 0, b.length)`, но дочерние 
классы могут переопределить его, если нужно.

**`public int read(byte[] b, int off, int len) throws IOException`**

Читает до len байт из входного потока в массив байт. Пытается считать len байт, но может считать и меньше. 
Количество реально считанных байт возвращается как int.

Этот метод блокирует выполнение текущего потока программы до тех пор, пока не появятся данные, не будет 
достигнут конец потока, либо возникнет исключение.

Если len равен нулю, то байты не считываются, и возвращается 0. В противном случае происходит попытка 
считать хотя бы один байт. Если никаких байт нет, так как был достигнут конец потока, то возвращается -1, 
иначе хотя бы один байт считывается и сохраняется в b.

**Первый байт считывается в `b[off]`, второй в `b[off + 1]` и так далее.**

Реализация этого метода в классе `InputStream` просто вызывает метод `read()` в цикле. Потомки могут 
переопределить это поведение на более оптимальное.

#### Работа метода `read(byte[] b)`
**Представим несколько уровней памяти, допустим:**

1. **Первый уровень:** JVM
2. **Второй уровень:** Операционная система
3. **Третий уровень:** Драйвер
4. **Четвертый уровень:** Какой-то винчестер

Предположим мы хотим считывать по одному байту с файла (**`read(1)`**), в каком мегабайты информации.
Так вот, так как файл находится на винчестере, а это самая отдаленная память от нас, то мы сначала
обратимся к операционной системе, у неё будет побольше своей памяти, она попросит считать не один байт,
а например 1 килобайт, после мы обратимся к драйверу, а у него будет ещё больше памяти и он захочет
считать 4 килобайта, после мы уже обратимся к винчестеру, а у хороших винчестеров много своей памяти
и он допустим захочет считать сразу 256 килобайт. После того как он считал, мы пойдем назад.

Винчестер считал 256кб, он обратится к драйверу, а у него нету столько памяти, у него всего 4кб, и
винчествер отдаст ему 4кб своей считанной информации, и у него останется 252кб. После драйвер 
обратится к ОС, она получит с 4кб только 1кб, а JVM только 1 байт, так как мы попросили только 1 байт.

Так вот, в дальнейших обращениях к считыванию байтов, у ОС уже будет прочитано 999 байт и не нужно будет
двигаться к другим уровням памяти, соответственно скорость работы приложения увеличится, после того как
весь 1кб будет считан с ОС, внимание будет обращено к более глубокой памяти - к драйверу, у него 4кб,
и он передаст 1кб ОС, а она в свою очередь 1 байт JVM и всё по новой.

#### java.io.OutputStream - _абстрактный класс, являющийся базовым классом для классов, реализующих выходной поток байт._

### Основные методы:

**`public void close() throws IOException`**

Закрывает выходной поток и освобождает ресурсы.

**`public abstract void write(int b) throws IOException`** 

Записывает байт в выходной поток.

**`public void write(byte[] b) throws IOException`**

Записывает b.length байт из указанного массива байт в выходной поток. Аналогично вызову `write(b, 0, b.length)`.

**`public void write(byte[] b, int off, int len) throws IOException`**

Записывает len байт из массива байт, начиная с off, в выходной поток. Реализация этого метода в `OutputStream` 
вызывает в цикле метод `write(int b)`. Дочерние классы могут переопределить его, дав более оптимальную реализацию.

#### Работа метода `write(byte[] b)`
**Представим несколько уровней памяти, допустим:**

1. **Первый уровень:** JVM
2. **Второй уровень:** Операционная система
3. **Третий уровень:** Драйвер
4. **Четвертый уровень:** Какой-то винчестер

При записи каких-нибудь данных, JVM сначала всю информацию какую мы хотим записать закидывает себе в буфер,
предположим что там 1кб памяти. Если эта память заканчивается, она обращается к более глубокому уровню памяти,
к ОС, у неё допустим 4кб памяти в буфере. В таком случае всё что было записано в первый уровень будет перекинуто
на второй уровень и освободит буфер в первом уровне. После данного алгоритма у JVM будет свободно 1кб памяти, а
у ОС 1кб занят и 3кб свободно в буфере. 

Соответственно, если память буфера будет заполнена, в ОС, внимание будет обращено к более глубокому отделу памяти,
и вся информация будет перекинута туда, а с остальных стерта и всё по новой.

**`public void flush() throws IOException`**

Записывает все байты из буфера. Некоторые реализации выходного потока могут накапливать байты в буфере и лишь 
потом реально записывать их. Вызов этого метода принудительно записывает данные из буфера и очищает его.

#### Работа метода `flush()`
##### (Для начала посмотрите раздел "Работа метода `write(byte[] b)`")
При вызове этого метода происходит некая волна, какая смывает всю набранную информацию во всех уровнях памяти 
и скидывает её на самый последний уровень - на память винчестера, то есть записывает всю информацию какая накопилась 
на всех уровнях памяти. Так как это очень долгая процедура, это может занимать в миллионы раз больше времени. 

Если обычный вызов `write(1)` может работать 1нс, то метод `flush()` может работать 10_000_000нс.

Ему нужно проверить что находится у JVM, всё скинуть на ОС, а вдруг у ОС уже занята память, тогда нужно всё что 
на ОС скинуть Драйверу, после скинуть то что в JVM на ОС, после с ОС на Драйвер, после это всё уже на Винчестер.
