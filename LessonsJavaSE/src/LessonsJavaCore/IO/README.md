# Java 8 потоки ввода/вывода
**Поток ввода/вывода (I/O Stream)** представляет собой источник данных или место их назначения. Потоки могут
представлять собой абсолютно различные источники и места назначения: файлы на дисках, устройства, сеть,
другие программы, массивы в памяти т. д.

Независимо от внутреннего устройства потоки представляют собой одинаковую модель для программы.
Поток представляет собой последовательность данных.

## Потоки байт
Все классы, работающие с потоками байт, наследуются от абстрактных классов java.io.InputStream или java.io.OutputStream.

_**java.io.InputStream** - абстрактный класс, являющийся базовым классом для всех классов, представляющий поток ввода._

#### Основные методы:
`public int available() throws IOException`

Возвращает кол-во байт, которое может быть прочитано из потока без блокировки. Другими словами,
он возвращает кол-во байт какое сейчас мгновенно могут прочитать, для получения такого же кол-ва байт,
доступ на какое-то время блокируется и после возвращается такое же кол-во байт. Некоторые реализации
InputStream возвращают полное кол-во байт в потоке, но не все. Не стоит использовать этот метод для
определения размера буфера, который будет хранить все данные из потока.

Грубо говоря этот метод используется для определения размера буфера. Тот размер, какой вернет этот метод,
будет считываться мгновенно. Этот размер используется чтобы при чтении не происходило долгих ожиданий,
потому что система может затормозить и выбирать, считывать ей ещё данные или же вернуть сколько уже имеется.

`public void close() throws IOException`

Закрывает поток и освобождает все ресурсы.

`public long skip(long n) throws IOException`

Пропускает n следующих байт во входном потоке. Может пропустить меньшее количество байт по какой-нибудь
причине. Возвращается реальное количество пропущенных байт.

`public boolean markSupported()`

Возвращает true, если реализация InputStream поддерживает методы mark() и reset().

`public void mark(int readlimit)`

Помечает текущую позицию во входной строке. Каким-то образом запоминает все считанные после вызова этого
метода данные и может вернуть те же самые данные ещё раз после вызова метода reset(). Если после вызова
метода mark(int readLimit) из потока было прочитано больше readLimit байт, то поток не обязан запоминать
что бы то ни было. Работает только если markSupported() возвращает true.

`public void reset() throws IOException`

Поток возвращается в такое состояние, что все вызовы методов read() в дальнейшем будут возвращать
те же данные, которые они возвращали с момента последнего вызова метода mark() (либо с начала потока,
если метод mark() не был вызван ни разу).