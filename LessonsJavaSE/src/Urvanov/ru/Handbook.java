package Urvanov.ru;

/**
 * * * * * ЧТО Я УЗНАЛ НОВОГО * * * * *
 *
 * import static - можно прописать импорт для статической переменной
 *
 * continue - оператор, позволяет пропустить текущую итерацию и перейти сразу к следующей итерации цикла              *
 *
 * Сигнатура метода - это имя метода вместе со списком параметров
 *
 * Фактические параметры или аргументы - это то, что реально было передано в функцию, метод или процедуру             *
 *
 * public void sum (int... parameter) { } - метод, принимающий произвольное число параметров
 *
 * Ключевое слово this может также использоваться для вызова из конструктора класса другого конструктора этого класса.
 * * * Вызов другого конструктора должен быть обязательно первым оператором/инструкцией в конструкторе:
 * * *
 * * * public Goblin(double health, int ammo) {
 * * *     this(health, ammo, 0); // ... остальная инициализация.
 * * * }
 * * *
 * * * public Goblin(double health, int ammo, int gold) {
 * * *     this.health = health;
 * * *     this.ammo = ammo;
 * * *     this.gold = gold;
 * * * }
 *
 * При создании объектов каждый объект получает свой отдельный набор переменных экземпляров.                          *
 * * * Если же нужно сделать какую-то переменную общей для всех экземпляров, то используется ключевое слово static.
 * * * Рекомендуется всегда обращаться к статическим свойствам через имя класса, чтобы подчеркнуть,
 * * * что оно относится именно к классу.
 *
 * Ключевое слово final может применяться к методу, тогда этот метод нельзя переопределять в классах-потомках для
 * * * методов экземпляров и нельзя скрывать (hide) в классах потомках для случая статических методов.
 * * * Можно применить final ко всему классу, что означает, что у класса не может быть потомков, то есть будет нельзя
 * * * наследоваться от этого класса.
 *
 * Если выражение инициализации не помещается в одну строку, или требуется обработка ошибок, использование циклов     *
 * * * и прочее, то можно использовать блоки инициализации:
 * * * class Goblin {
 * * *     static int idCounter;
 * * *     int money;
 * * *
 * * *     static {
 * * *         // Инициализация статических полей
 * * *         idCounter = 3;
 * * *     }
 * * *
 * * *     {
 * * *         // Инициализации переменных экземпляров.
 * * *         money = 300;
 * * *     }
 * * * }
 * * * Блоки статической инициализации выполняются один раз при инициализации класса. Может быть несколько блоков
 * * * инициализации, и в таком случае они будут выполняться в порядке появления в исходном файле сверху вниз.
 * * *
 * * * Последовательность действий JVM:
 * * * 1. Вычисляются аргументы конструктора. Если конструктор начинается с вызова другого конструктора этого класса,
 * * *    то вычисляются аргументы его и т. д.
 * * * 2. Если конструктор не начинается с вызова другого конструктора, то он начинается с явного или неявного вызова
 * * *    конструктора базового класса. Выполняется этот конструктор базового класса.
 * * * 3. Выполняются все выражения инициализации экземпляров и блоки инициализации экземпляров в том порядке,
 * * *    в котором они объявлены в исходном файле, словно они идут одним блоком.
 * * * 4. Выполняется остаток тела конструктора.
 *
 * Интерфейсы в Java - это некоторый контракт, описание методов, которые обязательно должны присутствовать в классе,
 * * * реализующем этот интерфейс. Интерфейсы позволяют иметь несколько различных реализаций одного и того же действия,
 * * * но выполняемого различными способами или с различными видами данных.
 * * *
 * * * - Тела методов могут быть только у статических методов и методов по умолчанию.                                 *
 * * *
 * * * - Нельзя создать экземпляр интерфейса. Интерфейс может быть только реализован каким-либо классом,
 * * *   либо наследоваться другим интерфейсом.
 * * *
 * * * - Любой интерфейс является abstract, нет никакого смысла писать дополнительно это слово при объявлении         *
 * * *   интерфейса, хотя компилятор и проглотит фразу public abstract interface Monstr.
 * * *
 * * * - Любое объявление поля в интерфейсе является public static final.                                             *
 * * *
 * * * - Поскольку методы из интерфейса неявно имеют модификатор доступа public, то мы тоже должны объявить в классе
 * * *   эти методы как public, иначе будет ошибка компиляции.
 * * *
 * * * - Интерфейс может расширять другие интерфейсы наследуясь от них с помощью ключевого слова extends.
 * * *
 * * * - Интерфейс может содержать в себе вложенные типы:                                                             *
 * * *
 * * *   public interface Elemental extends Monstr, Obstacle, Ghost, Enemy {
 * * *      // Константы и методы...
 * * *      class ElementalForce {
 * * *          private double x;
 * * *          private double y;
 * * *
 * * *          public void someMethod1() {
 * * *
 * * *          }
 * * *      }
 * * *   }
 * * *   - Вложенные типы неявно public и static.
 * * *   - Вложенный тип не может иметь модификатор доступа private или protected, иначе будет ошибка компиляции.
 * * *
 * * * - Если вам понадобилось добавить новый метод в интерфейс, то вы можете создать новый интерфейс,                *
 * * *   расширяющий старый и добавляющий этот метод:
 * * *
 * * *   public interface ExtendedMonstr extends Monstr {
 * * *      void doSomething();
 * * *   }
 * * *
 * * *   Теперь пользователи смогут выбрать, остаться ли им на старом интерфейсе, либо перейти на новый и получить
 * * *   дополнительные возможности.
 * * *
 * * *   Или вы можете использовать методы по умолчанию (default methods):                                            *
 * * *
 * * *   public interface Monstr {
 * * *      boolean isSensitiveToSilver();
 * * *      void logic(VisibleWorld visibleWorld);
 * * *
 * * *      // Новый метод
 * * *      default void doSomething() {
 * * *       // Некий код
 * * *      }
 * * *   }
 * * *   Для методов по умолчанию нужно обязательно указать реализацию. Эта реализация может вызывать другие методы из
 * * *   этого интерфейса и интерфейсов, от которых он наследуется.
 * * *
 * * * - Интерфейс может содержать статические методы, как и класс. Статические методы могут иметь реализацию и
 * * *   относятся к самому типу и вызываются через него.
 * * *
 *
 * Класс, который наследуется от другого класса, называется подклассом (subclass), дочерним классом (child class),
 * * * потомком или расширенным классом (extended class).
 */

public class Handbook {
}
