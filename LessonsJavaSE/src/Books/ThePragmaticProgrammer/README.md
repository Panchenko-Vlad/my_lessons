#### The Pragmatic Programmer (2007)

------------------------------------

# Все подсказки, какие встречались в течении всей книги

#### _(Данные подсказки помогут улучшить вашу продуктивность и квалификацию)_

-----------------------------------------------------------------------------

1. **Позаботьтесь о вашем ремесле.** _Нужно всегда следить за качеством своей работы._
2. **Думай! О своей работе.** _Никогда не пользуйтесь автопилотом. Думайте постоянно, 
     критикуя свою работу в реальном масштабе времени._
3. **Представьте варианты решения проблемы, а не варианты отговорок.** _Перед тем как подойти к кому-либо, 
     чтобы высказать, почем что-либо не может быть сделано или уже сломалось, остановитесь и прислушайтесь 
     к себе. Вместо отговорок представьте варианты решения проблемы._
4. **Не живите с разбитыми окнами.** _Не оставляйте "разбитые окна" (неудачные конструкции, неверные решения 
     или некачественный текст программы) без внимания. Как только их обнаружите, чините сразу. Если нет 
     времени на надлежащий ремонт, забейте окно досками._
5. **Будьте катализатором изменений.**
6. **Следите за изменениями.**
7. **Сделайте качество одним из пунктом требований.**
8. **Инвестируйте регулярно в ваш портфель знаний.**
9. **Критически анализируйте прочитанное и услышанное.** _Опасайтесь фанатиков, настаивающих на том, 
     что их догма обеспечивает единственный правильный ответ - последний может быть применим или 
     неприменим к вам и вашему проекту._
10. **Важно что говорить и как говорить.** _Поскольку вы не работаете в безвоздушном пространстве, вам 
      необходимо уметь общаться. Чем эффективнее это общение, тем более влиятельным вы становитесь._
11. **Не повторяй самого себя.** _Проще говоря, максимально избегайте дублирования._
12. **Сделайте так, чтобы программу можно было легко использовать повторно.**
13. **Исключайте взаимодействие между объектами, не относящимися друг к другу.**
14. **Не существует окончатльеных решений.** _Ошибка состоит в предположении, что любое решение высечено 
      на камне, и неготовности к случайностям, которые могут возникнуть. Вместо того, чтобы высекать 
      решения на камне, рассматривайте их так, как будто они начерчены на морском песке. В любой момент 
      может накатиться большая волна и смыть их._
15. **Пользуйтесь трассирующими пулями, для того чтобы найти цель.** _Трассирующие пули помещаются на 
      пулеметную ленту через равные промежутки наряду с обычными боеприпасами. При стрельбе фосфоср, 
      содержащийся в них, загорается и оставляет пиротехнический след, идущий от пулемета до любого места, 
      в которое они попадают. Если в цель попадают трассирующие пули, то, значит, в нее попадут и обычные._
16. **Создавайте прототипы, чтобы учиться на них.** _Создание прототипов способствует приобретению опыта. 
      Значение этого опыта заключается не в созданной программе, а в полученных уроках. В этом и состоит 
      смысл прототипов._
17. **Программируйте ближе к предметной области вашей задачи.** _Мы полагаем, что вам следует рассмотреть 
      способы перемещения вашего объекта ближе к предметной области проблемы - будь то простейший язык 
      для конфигурирования и управления прикладной программмой или же более сложный язык для обозначения 
      правил или процедур._
18. **Проводите оценки во избежание сюрпризов.**
      - Проверить требования
      - Проанализировать риск
      - Осуществить проектирование, реализацию, интеграцию
      - Проверить правильность при работе с пользователями
19. **Уточняйте график проекта на основе текста программы.** _Это может не понравиться руководству, которому 
      обычно нужно единственная надежная цифра ещё до начала проекта. Вам придется помочь им осознать, 
      что команда, ее производительность и среда будут определять график выполнения. Формализуя эту процедуру
      и уточняя график (что является частью итерационного процесса), вы сможете дать руководству самые 
      точные оценки графика выполнения, какие только сможете._
20. **Сохраняйте знанаия в формате простого текста.**
21. **Используйте сильные стороны командных оболочек.** _Строчные команды могут быть непонятными
      и компактными, но они обладают мошностью и краткостью. И поскольку они могут сводиться в файлы 
      сценариев (или командные файлы в системе Windows), то вы можете создавать последовательности 
      команд для автоматизации часто выполняемых процедур._
22. **Используйте один текстовый редактор, но по максимуму.** _Выберите какой-либо редактор, тщательно 
      изучите его и используйте во всех задачах, связанных с редактированием текста._
23. **Всегда используйте управление исходным текстом программы.** _Всегда. Даже если ваша команда состоит из 
      одного человека и продолжительность проекта составляет одну неделю. Даже если это есть прототип на 
      выброс. Даже если материал, с которым вы работаете, не является исходным текстом программы. 
      Убедитесь, что все находится под контролем - используйте систему контроля версий._
24. **Занимайтесь устранением проблемы, а не снятием обвинений.** _На самом деле, не важно, кто виноват 
      в ошибке - вы или кто-то другой. Это все равно остается вашей проблемой._
25. **Не паникуйте.** _Легко впасть в панику, особенно если вы связаны контрольными сроками или работаете 
      с нервным руководителем или заказчиком, стоящим у вас над душой в то время, когда вы пытаетесь найти 
      причину ошибки. Но очень важно сделать шаг назад и подумать над тем, что же на самом деле является 
      первопричиной симптомов, которые, по вашему убеждению, являются ошибкой._
26. **Ищите ошибки вне пределов операционной системы.** _Помните: увидев следы копыт, думайте о лошадях, 
      а не о зебрах. Скорее всего, операционная система не нарушена. Да и база данных находится в прекрасном 
      состоянии._
27. **Не предполагайте - доказывайте.** _Не приукрашивайте подпрограмму или фрагмент текста программы, 
      вызвавшего ошибку, только потому, что "знаете", что он работает нормально. Вначале докажите это. 
      Докажите это в реальном контексте, с реальными данными, с реальными граничными условиями._
28. **Изучите язык обработки текстов.** _Выучите сценарный язык (Python, Perl и т. д.), с помощью него, 
      вы сможете быстро реализовать свою идею и посмотреть её в работе._
29. **Пишите текст программы, которая пишет текст программы.**
30. **Невозможно написать совершенную программу.** _Ваши чувства задеты? Не стоит принимать эту подсказку 
      близко к сердцу. Примите ее как жизненную аксиому. Заключите ее в объятья. Восславьте ее. Поскольку 
      совершенных программ в природе не существует._
31. **Проектируйте в соответствии с контрактами.**
32. **Пусть аварийное завершение работы программы произойдет как можно раньше.** _Все ошибки дают вам 
      информацию. Вы могли внушить себе, что ошибка произойти не может, и проигнорировать эту информацию. 
      В отличие от вас, прагматики говорят себе, что если ошибка имеет место, то произошло что-то очень 
      скверное._
33. **Если что-либо не может произойти, воспользуйтесь утверждениями, которые гарантируют, 
      что это не произойдет вовсе.** _Всякий раз, когда вы начинаете думать: "Ну конечно, 
      такого просто не может произойти", проверяйте это высказывание с помощью программы. 
      Самый простой способ осуществить это - использовать утверждения._
      - Используйте встроенную библиотеку в Java - Assert и производите утверждения и если в чем-то уверены.
      - Не отключайте утверждения. 
      > Отключение утверждений при доставке программы заказчику сродни хождению 
      > по канату без страховочной сетки на том основании, что когда-то вы уже так делали.
34. **Пользуйтесь исключениями только в исключительных ситуациях.** _Мы полагаем, что не стоит 
      злоупотреблять исключениями для нормального хода выполнения программы; они должны быть 
      зарезервированы для нештатных ситуацмй. Предположим, что неперехваченное исключение прекратит 
      работу вашей программы и спросите себя: "А будет ли эта программа исполняться, если удалить 
      все обработчики исключений?" Если ответ отрицательный, то вполне возможно, что исключения 
      используются в обстоятельстввх, их не требующих._
35. **Доводите до конца то, что начинаете.** _В большинстве случаев эту подсказку применить несложно. 
      Она всего лишь означает, что подпрограмма или объект, который назначает ресурс, должен вести 
      ответственность за освобождение этого ресурса._
      - Освобождайте ресурсы в последовательности, обратной той, в которой происходило их распределение. При 
        этом можно избежать появления "осиротевших" ресурсов, если один из них содержит ссылки на другой.
      - При распределении одного и того же набора ресурсов в различных местах программы необходимо 
        осуществлять эту операцию в одном и том же порядке. Это уменьшает вероятность взаимоблокировки.
36. **Минимизируйте связывание между модулями.** _Закон Деметера для функций гласит, что любой метод 
      некоторого объекта должен обращаться только к методам принадлежащим:_
      - _самим себе._
      - _любым параметрам, переданным в метод._
      - _любым создаваемым им объектам._
      - _любым непосредственно содержащимся объектам компонентов._
37. **Осуществляйте настройку, а не интеграцию.** _Используйте метаданные для спецификации вариантов 
      настройки приложения: подгонки параметров, глобальынх параметров пользователя, каталога, в который 
      производится установка приложения, и т.д._
38. **Помещайте абстракции в текст программы, а подробности - в область метаданных.** _Придерживайтесь 
      общего правила: программируйте для общего случая и помещайте всю специфику в другое место - за 
      пределы компилируемого ядра программы._
39. **Анализируйте последовательность операций для увеличения параллелизма.** _Описание по созданию 
      диаграммы, для определения максимального параллелизма:_
      > Диаграмма состоит из совокупности действий, изображенных в виде прямоуголь­
      > ников с закругленными уголками. Стрелка, выходящая из одной операции, идет либо
      > к другой операции (которая может начаться после того, как первая закончится) или к
      > жирной линии, называемой полосой синхронизации. Как только все операции, на­
      > правленные к полосе синхронизации, завершаются, то вы можете перемещаться по
      > стрелкам, идущим от полосы синхронизации. Операция, на которую не указывают ни­
      > какие стрелки, может быть начата в любой момент.
      > Вы можете использовать диаграммы, чтобы добиться максимального параллелиз­
      > ма, определив те процессы, которые могли бы осуществляться параллельно, но не де­
      > лают этого.
      
      _Польза от многопоточного программирования:_
      > Поскольку Java все чаще принимается в качестве платформы, многих разработчики
      > перешли к многопоточному программированию. Но программирование с использова­
      > нием потоков налагает на конструкцию некоторые ограничения — и это хорошо. Эти
      > ограничения в действительности настолько полезны, что нам хотелось бы пребывать
      > под их благодатным покровом, когда бы мы ни занимались написанием программ. Это
      > поможет нам делать нашу программу несвязанной и бороться с так называемым про­
      > граммированием в расчете на стечение обстоятельств.
      > При работе с линейной программой легко сделать предположения, которые в ко­
      > нечном итого приведут к небрежно написанным программам. Но параллелизм застав­
      > ляет вас задумываться о происходящем несколько глубже — вы больше не находи­
      > тесь в безвоздушном пространстве. Поскольку многие события могут теперь
      > происходить "в одно и то же время", вы можете внезапно столкнуться с зависимостя­
      > ми, основанными на факторе времени. 
40. **Проектируйте, используя службы.**
41. **При проектировании всегда есть место параллелизму.**
      _Если мы проектируем с учетом параллелизма, то со временем нам легче 
       обеспечивать расширяемость и производительность, а если этот момент 
       не настает, то мы все равно получаем выгоду от более четкого интерфейса.
       Так, может быть, пора?_
       ***********************
    #### Служба событий CORBA
      > Служба событий CORBA позволяет объектам-участникам отправлять и полу­
      > чать уведомления о событиях через общую шину, так называемый канал со­
      > бытий. Канал событий принимает решение по обработке событий, а также
      > осуществляет резделени е производителей и потребителей событий. Он ра­
      > ботает в двух основных режимах: "проталкивание" и "вытягивание".
      > 
      > Хотя служба событий CORBA может использоваться для реализации всех
      > событийных моделей, описанных в данном разделе, ее можно рассматри­
      > вать и в другом качестве. CORBA облегчает связь между объектами, напи­
      > санными на различных языках программирования и выполняющимися на
      > географически рассредоточенных машинах с различными архитектурами.
 
42. **Отделяйте визуальные представления от моделей.** 
      _Действуя подобным образом, вы можете извлечь пользу из некоторых интересных
       возможностей. Вы можете поддерживать множественные визуальные представления
       для одной и той же модели данных. Вы можете использовать обычные средства про­
       смотра со многими различными моделями данных. Вы даже можете поддерживать
       множественные контроллеры для обеспечения нетрадиционных механизмов ввода
       данных._
       ********
    #### MVC:
      > Хорошим примером принципа "модель-визуальное представление-контроллер" яв­
      > ляется графический элемент в древовидной схеме Java. Элемент, который отобра­
      > жает обходимое дерево, активизируемое щелчком мыши, в действительности пред­
      > ставляет собой набор нескольких различных классов, организованных по шаблону
      > "модель—визуальное представление—контроллер".
      > Все, что вам нужно сделать для получения полнофункционального элемента де­
      > рева, — это обеспечить источник данных, который соответствует интерфейсу
      > TreeModel. Ваша программа теперь становится моделью дерева.
      > 
      > Визуальное представление создается классами TreeCellRenderer и TreeCellEditor,
      > которые могут быть унаследованы и настроены для обеспечения различных цветов,
      > шрифтов и пиктограмм в графическом элементе. JTree действует в качестве контролле­
      > ра для элемента дерева и обеспечивает некоторую общую функциональную возмож­
      > ность просмотра.
 
43. **Используйте доски объявлений для координации потоков работ.** 
      _Доска объявлений позволяет полностью отделять объекты друг от друга, обеспе­
       чивая тем самым пространство, на котором потребители и производители информа­
       ции могут обмениваться данными анонимно и в асинхронном режиме. Как вы могли
       догадаться, это также позволяет уменьшить объем программ, которые нам приходит­
       ся писать._
       ***********
    #### Как организовать доску объявлений:
      > Когда детективы ведут расследовани е крупных дел, то доска объявлений мо­
      > жет прийти в беспорядок и найти н а ней нужные данные станет сложно. Ре­
      > шение состоит том, чтобы разбить доску на секциии начать каким-то обра­
      > зом упорядочивать данные.
      > 
      > Различные программные системы осуществляют это разбиение различными
      > способами; одни используют достаточно однородные зоны или группы интере­
      > сов, тогда как другие используют боле е иерархичную древовидную структуру. 

44. **Не пишите программы в расчете на стечение обстоятельств.** 
      _На всех уровнях люди работают, держа многие предположения в голове, но эти
       предположения редко документируются и часто вызывают противоречия между раз­
       работчиками. Предположения, которые не основаны на известных фактах, способны
       отравить любые проекты._ 
       ************************
    #### Преднамеренное программирование
      - Всегда отдавайте себе отчет в том, что вы делаете.
      j-Ie пишите программ вслепую^Попытка написать приложение, которое вы
      до конца не понимаете, или использовать технологию, с которой вы не знако­
      мы, становится поводом к тому, что вы будете введены в заблуждение слу­
      чайными совпадениями.
      - Действуйте исходя из плана, неважно, где он составлен^ - у вас в голове, на
      кухонной салфетке или на огромной "простыне", полученной с помощью
      CASE-средств.
      - Полагайтесь только на надежные предметы. Не вводите себя в зависимость
      от случаев или предположений. Если вы не можете понять, в чем состоит
      различие при специфических обстоятельствах, предполагайте худшее.
      - Документируйте ваши предположения.
      - Тестируйте не только вашу программу, но и ваши предположения. Не гадай­
      те, попробуйте осуществить это на деле. Напишите программу контроля для
      проверки ваших предположений (см. "Программирование утверждений").
      Если ваше предположение верно, то вы улучшили документирование вашей
      программы. Если вы обнаружили, что предположение ошибочно, тогда счи­
      тайте, что вам повезло.
      - Определите приоритеты в вашей работе! Уделите время аспектам, представ­
      ляющим важность; скорее всего, они окажутся непростыми. При отсутствии
      надлежащих фундаментальных принципов или инфраструктуры все блестя­
      щие "бантики" будут просто неуместны.
      - "Не будьте рабами прошлого; Не позволяйте существующей программе
      диктовать свою волю той программе, за которой будущее. Если програм­
      ма устаревает, она может быть полностью заменена.

45. **Оцените порядок ваших алгоритмов.** 
      _Во всех случаях, когда вы пишете простой цикл, то знайте, что имеете дело
       с алгоритмом О(п). Если же этот цикл содержит внутренний цикл, то речь идет о
       O(m х n). Вы обязаны задаться вопросом: а насколько велики эти значения? Если эти
       значения ограничены сверху, то вы можете представить, сколько времени потребует­
       ся на выполнение программы. Если эти цифры зависят от внешних факторов (наподо­
       бие количества записей в запускаемом на ночь пакете программ или количества фа­
       милий в списке персоналий), то стоит остановиться и изучить влияние больших числе
       на время выполнения программы или объемы необходимой памяти._
       *************************************************************
      > Существуют несколько подходов, которыми вы можете воспользоваться при ре­
      > шении потенциально возникающих проблем. Если у вас есть алгоритм, который явля­
      > ется O(n2), попробуйте действовать по принципу "разделяй и властвуй", что может
      > уменьшить время выполнения до O(nlg(n)).
      > 
      > Если вы не уверены в том, что ваша программа будет выполняться в течение опре­
      > деленного времени, или в том, что она затребует определенный объем памяти, попы­
      > тайтесь запустить ее, варьируя количество обрабатываемых записей или другие пара­
      > метры, способные оказать воздействие на время выполнения программы. Затем
      > постройте график на основе полученных результатов и получите представление о
      > форме кривой. Изгибается ли она кверху, представляет собой прямую линию или
      > сглаживается с увеличением размера входного массива данных? Представление об
      > этом можно получить, исходя из трех или четырех точек. 
      ********************************************************
    #### Скорость алгоритма
    ![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/Books/ThePragmaticProgrammer/Screenshots/speed_algorithm.png)
    ***********************
    #### Оценка с точки зрения здравого смысла
    - Простые циклы. Если простой цикл выполняется от 1 до n, то алгоритм, ско­
      рее всего, является О(n) — время находится в линейной зависимости от n.
      Примерами этого являются исчерпывающий поиск, поиск максимального
      элемента в массиве и генерация контрольной суммы. 
      
    - Вложенные циклы. Если вы помещаете один цикл в другой, то ваш алго­
      ритм становится О(m х n), где тип — пределы этих двух циклов. Обычно
      это свойственно простым алгоритмам сортировки, типа пузырьковой сор­
      тировки, где внешний цикл поочередно просматривает каждый элемент
      массива, а внутренний цикл определяет местонахождение этого элемента в
      результирующем массиве. Подобные алгоритмы чаще всего сортировки
      стремятся к O(n2).
      
    - Алгоритм двоичного поиска. Если ваш алгоритм делит пополам набор эле­
      ментов, который он рассматривает всякий раз в цикле, то скорее всего он ло­
      гарифмический O(lg(n)). Двоичный поиск в упорядоченном списке, обход 
      двоичного дерева и поиск первого установленного бита в машинном слове могут 
      быть O(lg(n)). 
      
    - Разделяй и властвуй. Алгоритмы, которые разбивают входные данные на
      разделы, работают независимо с двумя половинами, и затем комбинируют
      конечный результат, могут представлять собой O(nlg(n)). Классический
      примером является алгоритм быстрой сортировки, который делит входной
      массив пополам и затем проводит рекурсивную сортировку в каждой из по­
      ловин. Хотя технически он является O(n2), поскольку его поведение ухудша­
      ется, когда он обрабатывает упорядоченные данные, но среднее время быст­
      рой сортировки составляет O(nlg{n)).
       
46. **Проверяйте ваши оценки.** 
      _При проведении тестирования программы сортировки со случайны­
       ми входными ключами вы можете удивиться ее работе с упорядоченным входным мас­
       сивом. Прагматики стараются обеспечивать как теоретическую, так и практическую
       базу. После всех проведенных оценок единственной определяемой временной харак­
       теристикой является скорость выполнения вашей программы в реальных условиях
       эксплуатации и с реальными данными._
       
47. **Реорганизация должна проводиться часто и как можно раньше.**
      _Переписывание, переработка и перепланирование текста программы описывается
       общим термином "реорганизация"._ 
       
      *********************************
      
      > Рассматривайте программу, нуждающуюся в реорганизации, как "опухоль".
      > Чтобы удалить ее, требуется хирургическое вмешательство. Вы можете начать сразу
      > и извлечь ее, пока она небольшая. Но если вы будете ждать, пока она вырастет и рас­
      > пространится, то удаление ее станет более дорогой и опасной процедурой. Подождите
      > еще, и вы можете потерять пациента окончательно. 
      
      **************************************************
  
    #### Мартин Фаулер предлагает ряд простых подсказок - как провести реорганизацию, чтобы это не принесло больше вреда, чем пользы:
      - Не пытайтесь одновременно производить реорганизацию и добавлять функ­
      циональные возможности.
      
      - Перед тем как начинать реорганизацию, убедитесь, что тестирование прошло
      успешно. Проводите тестирование как можно чаще. В этом случае вы сразу
      увидите нарушение, которое было вызвано внесенными изменениями.
       
      - Двигайтесь обдуманно и не спеша: переместите поле из одного класса в другой,
        объедините два подобных метода в суперкласс. Часто при реорганизации вно­
        сится много локальных изменений, которые приводят к серьезным сдвигам.
        Если выдвигаетесь без спешки и проводите тестирование после каждого шага,
        вы избежите длительной процедуры отладки. 

48. **Проектируйте с учетом тестирования.** 
      _Когда вы проектируете модуль или даже целую программу, вы обязаны проектиро­
       вать ее контракт и программу для проверки этого контракта. Проектируя программу, 
       которая проходит тестирование и выполняет соответствующий контракт, вы можете
       учесть граничные условия и другие аспекты, на которые в иных случаях не обратили
       бы внимания. Лучше всего устранять ошибки, избежав их с самого начала. На самом
       деле, при создании процедуры тестирования до реализации программы вам приходит­
       ся испытывать интерфейс, перед тем как принять его._
       
49. **Тестируйте ваши программы, в противном случае это сделают ваши пользователи.**

50. **Не пользуйтесь программой функции-мастера, которую не понимаете.**
      _Если вы все же используете функцию-мастера и не понимаете всей 
       создаваемой ею программы, то не сможе те управлять вашим собственным 
       приложением. Вы не сможете сопровождать его и будете затрачивать 
       неимоверные усилия при отладке._
       
51. **Не собирайте требования - выискивайте их.**
      _Требования редко лежат на поверхности. Обычно они находят­
       ся глубоко под толщей предположений, неверных представлений и политики._
       
52. **Работайте с пользователем, чтобы мыслить категориями пользователя.** 
      _Существует простая методика: чтобы взглянуть изнутри на требования ваших
       пользователей (которые часто являются весьма недостаточными), нужно самому
       стать пользователем. Пишете систему для службы поддержки? Посидите пару дней на
       телефоне вместе с опытным сотрудником службы поддержки. Занимаетесь автомати­
       зацией ручной системы управления складскими запасами? Поработайте на складе с
       неделю. Вы получите представление о реальном использовании системы и вдобавок
       будете просто поражены тем, насколько просьба "Можно я посижу рядом с вами не­
       дельку и посмотрю, как вы работаете?" способствует доверию и закладывает основы
       ваших взаимоотношений с пользователями. Но не путайтесь у них под ногами!_
       ***************************************************************************
    ![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/Books/ThePragmaticProgrammer/Screenshots/script_template_1.png)
    
    ![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/Books/ThePragmaticProgrammer/Screenshots/script_template_2.png)
    
    ![CC0](https://github.com/Panchenko-Vlad/java-lessons/tree/master/LessonsJavaSE/src/Books/ThePragmaticProgrammer/Screenshots/script_template_3.png)
    
    #### Диаграммы сценариев использования
    Нам кажется невероятным, что кто-нибудь может всерьез воспринимать докумен­
    тирование информации, используя примитивные символы, подобные изображенным на
    рис. 7.3. Не будьте рабом любой системы обозначений: используйте любой метод об­
    щения, с помощью которого можно обмениваться требованиями с вашей аудиторией. 
    
    *****************************************************************************
    
    ***Требования не являются архитектурой. Требования - это не конструкция и не
       пользовательский интерфейс. Это потребность.***
       
53. **Абстракции живут дольше, чем подробности.**